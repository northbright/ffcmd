package ffcmd

import (
	"fmt"
	"strings"
)

// CreateOneSubSRTCmd is the command to create a SRT file which contains 1 subtitle only.
// It can be used to generate commands to create / remove a simple SRT file used in ffmpeg's subtitles filter.
type CreateOneSubSRTCmd struct {
	srtFile   string
	videoFile string
	text      string
	start     string
	end       string
}

// NewCreateOneSubSRTCmd returns a new command to create SRT file.
// srtFile: filename of the SRT file.
// videoFile: filename of video file to add subtitles.
// When end is empty, it'll try to get the duration of the video as end time.
// text: subtitle text.
// start, end: timestamp in the SRT file.
func NewCreateOneSubSRTCmd(srtFile, videoFile, text, start, end string) (*CreateOneSubSRTCmd, error) {
	if srtFile == "" {
		return nil, fmt.Errorf("empty SRT file name")
	}

	if text == "" {
		return nil, fmt.Errorf("empty subtitle text")
	}

	// Escape exclamation mark.
	text = strings.ReplaceAll(text, "!", `\!`)

	return &CreateOneSubSRTCmd{srtFile: srtFile, videoFile: videoFile, text: text, start: start, end: end}, nil
}

// NewCreateOneSubSRTCmdForImageClip returns a new command to create SRT file for a video generated by a image.
// srtFile: filename of the SRT file.
// text: subtitle text.
// duration: duration of the video generated by a image.
func NewCreateOneSubSRTCmdForImageClip(srtFile, text string, duration float32) (*CreateOneSubSRTCmd, error) {
	if duration <= 0 {
		return nil, fmt.Errorf("invalid duration")
	}

	start := "00:00:00,000"

	ts, err := NewTimestampFromSecond(duration)
	if err != nil {
		return nil, fmt.Errorf("NewTimestampFromSecond() error: %v", err)
	}
	end := ts.StringForSRT()

	return NewCreateOneSubSRTCmd(srtFile, "", text, start, end)
}

// String returns the command string to run.
func (cmd *CreateOneSubSRTCmd) String() (string, error) {
	var start, end string
	str := ""

	if cmd.start == "" {
		start = "00:00:00,000"
	} else {
		ts, err := NewTimestamp(cmd.start)
		if err != nil {
			fmt.Printf("cmd.start: %s\n", cmd.start)
			return "", fmt.Errorf("invalid start time format")
		}
		start = ts.StringForSRT()
	}

	if cmd.end == "" {
		if cmd.videoFile == "" {
			return "", fmt.Errorf("both end time and video filename are empty, can not get end timestamp")
		}

		str = fmt.Sprintf(`ffprobe -v error -select_streams v:0 -show_entries stream=duration -of csv=s=,:p=0 "%s" | awk -F. '{ print $1 }' | read sec; hh=$((sec / 3600)); mm=$((sec %% 3600 / 60)); ss=$((sec %% 3600 %% 60)); printf -v end "%%02d:%%02d:%%02d,000" hh mm ss; echo -ne "1\n%s --> $end\n%s" > "%s"`, cmd.videoFile, start, cmd.text, cmd.srtFile)
	} else {
		ts, err := NewTimestamp(cmd.end)
		if err != nil {
			return "", fmt.Errorf("invalid end time format")
		}
		end = ts.StringForSRT()

		str = fmt.Sprintf(`echo -ne "1\n%s --> %s\n%s" > "%s"`, start, end, cmd.text, cmd.srtFile)
	}

	return str, nil
}

func (cmd *CreateOneSubSRTCmd) Run(dir string, fn ReadOutputFunc) error {
	str, err := cmd.String()
	if err != nil {
		return fmt.Errorf("cmd.String() error: %v", err)
	}

	return RunCmd(dir, str, fn)
}

// RemoveOneSubSRTCmd represents the command to remove a SRT file.
type RemoveOneSubSRTCmd struct {
	srtFile string
}

// NewRemoveOneSubSRTCmd returns a command to remove a SRT file.
// srtFile: filename of SRT file.
func NewRemoveOneSubSRTCmd(srtFile string) (*RemoveOneSubSRTCmd, error) {
	if srtFile == "" {
		return nil, fmt.Errorf("empty SRT filename")
	}

	return &RemoveOneSubSRTCmd{srtFile: srtFile}, nil
}

// String returns the commands string to run.
func (cmd *RemoveOneSubSRTCmd) String() (string, error) {
	return fmt.Sprintf(`rm "%s"`, cmd.srtFile), nil
}

func (cmd *RemoveOneSubSRTCmd) Run(dir string, fn ReadOutputFunc) error {
	str, err := cmd.String()
	if err != nil {
		return fmt.Errorf("cmd.String() error: %v", err)
	}

	return RunCmd(dir, str, fn)
}
